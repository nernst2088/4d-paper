import os
from datetime import datetime
from typing import List, Dict, Any
import markdown2
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Preformatted
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
import logging
from src.core.models.paper_model import DynamicPaper, FourDDataReference
from src.core.i18n.translator import _

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("TemplateEngine")

class TemplateEngine:
    """Template engine for generating dynamic paper content"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
    
    def generate_paper_content(
        self,
        paper: DynamicPaper,
        four_d_data_refs: List[FourDDataReference],
        version_number: int,
        update_reason: str
    ) -> str:
        """
        Generate Markdown content for paper version
        
        Args:
            paper: DynamicPaper object
            four_d_data_refs: List of 4D data references
            version_number: Version number
            update_reason: Update reason
            
        Returns:
            Markdown content
        """
        # Generate header
        header = f"""
# {paper.title}

**{_('Dynamic Paper ID')}**: {paper.paper_id}  
**{_('Version')}**: {version_number}  
**{_('Created')}**: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}  
**{_('Research Purpose')}**: {paper.research_purpose}  

## {_('Version Update Notes')}
{update_reason}

## {_('4D Data References')}
"""
        
        # Add 4D data references
        data_section = ""
        for i, data_ref in enumerate(four_d_data_refs, 1):
            space_info = ""
            if data_ref.space_coordinate:
                coord = data_ref.space_coordinate
                space_info = f" ({_('Location')}: {coord.latitude}, {coord.longitude}, {coord.altitude}m)"
            
            data_section += f"""
### {i}. {_('Data ID')}: {data_ref.data_id}
- {_('Type')}: {data_ref.data_type}
- {_('Timestamp')}: {data_ref.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}{space_info}
- {_('Hash')}: {data_ref.data_hash}
- {_('Description')}: {data_ref.description}

"""
        
        # Add methodology section
        methodology = f"""
## {_('Research Methodology')}
{_('This dynamic paper is generated automatically from 4D research data (3D spatial + time dimension). All data is cryptographically hashed to ensure integrity and traceability.')}

## {_('Long-Term Tracking')}
{_('This paper supports long-term research tracking (10,000+ years) with complete version history and spatial-temporal data integration.')}

## {_('Version History')}
{_('All versions are immutable and traceable. To view previous versions, use the 4D-Paper version tracking system.')}

---
*Generated by 4D-Paper System - Dynamic Academic Paper Framework*
"""
        
        # Combine all sections
        content = header + data_section + methodology
        
        logger.info(f"Generated content for {paper.paper_id} v{version_number}")
        return content
    
    def generate_pdf(self, markdown_content: str, output_path: str):
        """
        Convert Markdown content to PDF
        
        Args:
            markdown_content: Markdown content
            output_path: Output PDF path
        """
        # Create PDF document
        doc = SimpleDocTemplate(
            output_path,
            pagesize=letter,
            rightMargin=inch/2,
            leftMargin=inch/2,
            topMargin=inch/2,
            bottomMargin=inch/2
        )
        
        # Convert Markdown to plain text for PDF
        html = markdown2.markdown(markdown_content)
        story = []
        
        # Split content into lines and format for PDF
        lines = markdown_content.split('\n')
        for line in lines:
            if line.startswith('# '):
                # Heading 1
                story.append(Paragraph(line[2:], self.styles['Heading1']))
            elif line.startswith('## '):
                # Heading 2
                story.append(Paragraph(line[3:], self.styles['Heading2']))
            elif line.startswith('### '):
                # Heading 3
                story.append(Paragraph(line[4:], self.styles['Heading3']))
            elif line.startswith('**') and line.endswith('**'):
                # Bold text
                story.append(Paragraph(line, self.styles['Normal']))
            elif line.startswith('- '):
                # List item
                story.append(Paragraph(f"â€¢ {line[2:]}", self.styles['Normal']))
            elif line.strip() == "":
                # Empty line
                story.append(Spacer(1, 6))
            else:
                # Normal text
                story.append(Paragraph(line, self.styles['Normal']))
            
            # Add small space after each line
            story.append(Spacer(1, 3))
        
        # Build PDF
        doc.build(story)
        
        logger.info(f"PDF generated: {output_path}")
    
    def generate_docx(self, markdown_content: str, output_path: str):
        """
        Convert Markdown content to DOCX (placeholder implementation)
        
        Args:
            markdown_content: Markdown content
            output_path: Output DOCX path
        """
        # In production, use python-docx for proper DOCX generation
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(markdown_content)
        
        logger.info(f"DOCX (plain text) generated: {output_path}")